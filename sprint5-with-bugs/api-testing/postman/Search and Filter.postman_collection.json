{
	"info": {
		"_postman_id": "8e1fe17e-57a9-41ef-a4dc-4f3fd7625524",
		"name": "Search and Filter",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "47123385",
		"_collection_link": "https://duy-nguyen-ee114f4e-4953385.postman.co/workspace/duy-nguyen-ee114f4e's-Workspace~2a7c83c1-e5b8-43e5-81a4-c0affe89526a/collection/47123385-8e1fe17e-57a9-41ef-a4dc-4f3fd7625524?action=share&source=collection_link&creator=47123385"
	},
	"item": [
		{
			"name": "Search and Filter",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"try {\r",
							"    var jsonData = pm.response.json();\r",
							"} catch (e) {\r",
							"    var jsonData = null;\r",
							"}\r",
							"\r",
							"let expectedStatus = parseInt(pm.iterationData.get(\"expected_status\"));\r",
							"let testCaseId = pm.iterationData.get(\"id\") || \"N/A\";\r",
							"let testCaseDesc = pm.iterationData.get(\"description\") || \"Unknown test case\";\r",
							"\r",
							"let requestUrl = pm.request.url;\r",
							"let endpoint = requestUrl.toString();\r",
							"\r",
							"let detectedFilters = {\r",
							"    brand_id: null,\r",
							"    category_id: null,\r",
							"    min_price: null,\r",
							"    max_price: null,\r",
							"    search_term: null,\r",
							"    sort_field: null,\r",
							"    sort_direction: null\r",
							"};\r",
							"\r",
							"if (requestUrl.query.has(\"by_brand\")) {\r",
							"    detectedFilters.brand_id = requestUrl.query.get(\"by_brand\");\r",
							"}\r",
							"\r",
							"if (requestUrl.query.has(\"by_category\")) {\r",
							"    detectedFilters.category_id = requestUrl.query.get(\"by_category\");\r",
							"}\r",
							"\r",
							"if (requestUrl.query.has(\"between\")) {\r",
							"    let betweenParts = requestUrl.query.get(\"between\").split(\",\");\r",
							"    if (betweenParts.length >= 3 && betweenParts[0] === \"price\") {\r",
							"        detectedFilters.min_price = betweenParts[1];\r",
							"        detectedFilters.max_price = betweenParts[2];\r",
							"    }\r",
							"}\r",
							"\r",
							"if (requestUrl.query.has(\"sort\")) {\r",
							"    let sortParts = requestUrl.query.get(\"sort\").split(\",\");\r",
							"    if (sortParts.length >= 2) {\r",
							"        detectedFilters.sort_field = sortParts[0];\r",
							"        detectedFilters.sort_direction = sortParts[1];\r",
							"    }\r",
							"}\r",
							"\r",
							"if (requestUrl.query.has(\"q\")) {\r",
							"    detectedFilters.search_term = requestUrl.query.get(\"q\");\r",
							"}\r",
							"\r",
							"let allTestsPassed = true;\r",
							"let failureMessage = \"\";\r",
							"\r",
							"// ===== STATUS CODE CHECK =====\r",
							"if (pm.response.code !== expectedStatus) {\r",
							"    allTestsPassed = false;\r",
							"    failureMessage = `Returned status code ${pm.response.code} differs from expected ${expectedStatus}`;\r",
							"}\r",
							"\r",
							"// ===== BODY VALIDATION =====\r",
							"if (expectedStatus === 200 && pm.response.code === 200) {\r",
							"    if (!jsonData || !Array.isArray(jsonData.data)) {\r",
							"        allTestsPassed = false;\r",
							"        failureMessage = \"Response format invalid or missing data array\";\r",
							"    } else {\r",
							"        // ===== BRAND_ID CHECK =====\r",
							"        if (detectedFilters.brand_id) {\r",
							"            let validBrands = detectedFilters.brand_id.split(\",\").map(v => v.trim());\r",
							"            let invalidBrand = jsonData.data.find(p => !validBrands.includes(String(p.brand_id)));\r",
							"            \r",
							"            if (invalidBrand) {\r",
							"                allTestsPassed = false;\r",
							"                failureMessage = `Product ID ${invalidBrand.id} has brand_id=${invalidBrand.brand_id} not in [${validBrands}]`;\r",
							"            }\r",
							"        }\r",
							"        \r",
							"        // ===== CATEGORY_ID CHECK =====\r",
							"        if (detectedFilters.category_id) {\r",
							"            let validCategories = detectedFilters.category_id.split(\",\").map(v => v.trim());\r",
							"            let invalidCategory = jsonData.data.find(p => !validCategories.includes(String(p.category_id)));\r",
							"            \r",
							"            if (invalidCategory) {\r",
							"                allTestsPassed = false;\r",
							"                failureMessage = `Product ID ${invalidCategory.id} has category_id=${invalidCategory.category_id} not in [${validCategories}]`;\r",
							"            }\r",
							"        }\r",
							"        \r",
							"        // ===== PRICE RANGE CHECK =====\r",
							"        if (detectedFilters.min_price && detectedFilters.max_price) {\r",
							"            let min = parseFloat(detectedFilters.min_price);\r",
							"            let max = parseFloat(detectedFilters.max_price);\r",
							"            let invalidPrice = jsonData.data.find(p => p.price < min || p.price > max);\r",
							"            \r",
							"            if (invalidPrice) {\r",
							"                allTestsPassed = false;\r",
							"                failureMessage = `Product ID ${invalidPrice.id} has price=${invalidPrice.price} outside range [${min}-${max}]`;\r",
							"            }\r",
							"        }\r",
							"        \r",
							"        // ===== SEARCH TERM CHECK =====\r",
							"        if (detectedFilters.search_term) {\r",
							"            let searchLower = detectedFilters.search_term.toLowerCase();\r",
							"            let invalidSearch = jsonData.data.find(p => {\r",
							"                let name = String(p.name || \"\");\r",
							"                let desc = String(p.description || \"\");\r",
							"                return !(name.toLowerCase() + \" \" + desc.toLowerCase()).includes(searchLower);\r",
							"            });\r",
							"            \r",
							"            if (invalidSearch) {\r",
							"                allTestsPassed = false;\r",
							"                failureMessage = `Product ID ${invalidSearch.id} does not contain keyword \"${detectedFilters.search_term}\" in name/description`;\r",
							"            }\r",
							"        }\r",
							"        \r",
							"        // ===== SORT CHECK =====\r",
							"        if (detectedFilters.sort_field && detectedFilters.sort_direction) {\r",
							"            let field = detectedFilters.sort_field;\r",
							"            let direction = detectedFilters.sort_direction;\r",
							"            \r",
							"            if (jsonData.data.length < 2) {\r",
							"                console.log(\"Not enough data to check sorting\");\r",
							"            } else {\r",
							"                try {\r",
							"                    let arr = jsonData.data.map(p => {\r",
							"                        if (p[field] === undefined || p[field] === null) {\r",
							"                            return \"\";\r",
							"                        }\r",
							"                        return p[field];\r",
							"                    });\r",
							"                    \r",
							"                    let sortedArr = [...arr];\r",
							"                    \r",
							"                    if (direction === \"asc\") {\r",
							"                        sortedArr.sort((a, b) => {\r",
							"                            if (typeof a === 'string' && typeof b === 'string') {\r",
							"                                return a.toLowerCase().localeCompare(b.toLowerCase());\r",
							"                            }\r",
							"                            return (a > b ? 1 : a < b ? -1 : 0);\r",
							"                        });\r",
							"                    } else {\r",
							"                        sortedArr.sort((a, b) => {\r",
							"                            if (typeof a === 'string' && typeof b === 'string') {\r",
							"                                return b.toLowerCase().localeCompare(a.toLowerCase());\r",
							"                            }\r",
							"                            return (a < b ? 1 : a > b ? -1 : 0);\r",
							"                        });\r",
							"                    }\r",
							"                    \r",
							"                    let isSorted = true;\r",
							"                    for (let i = 0; i < arr.length; i++) {\r",
							"                        if (arr[i] !== sortedArr[i]) {\r",
							"                            isSorted = false;\r",
							"                            break;\r",
							"                        }\r",
							"                    }\r",
							"                    \r",
							"                    if (!isSorted) {\r",
							"                        allTestsPassed = false;\r",
							"                        failureMessage = `Data not sorted correctly by ${field} ${direction}`;\r",
							"                        console.log(\"Original array:\", arr);\r",
							"                        console.log(\"Expected sorted array:\", sortedArr);\r",
							"                    }\r",
							"                } catch (error) {\r",
							"                    console.error(\"Error when checking sorting:\", error);\r",
							"                    allTestsPassed = false;\r",
							"                    failureMessage = `Error when checking sorting: ${error.message}`;\r",
							"                }\r",
							"            }\r",
							"        }\r",
							"    }\r",
							"}\r",
							"\r",
							"// ===== FINAL EXPECT =====\r",
							"pm.test(`Test case #${testCaseId}: ${testCaseDesc}`, function() {\r",
							"    if (allTestsPassed) {\r",
							"        pm.expect(true).to.be.true;\r",
							"    } else {\r",
							"        pm.expect(false, failureMessage).to.be.true;\r",
							"    }\r",
							"});\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{authToken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{base_url}}{{endpoint}}",
					"host": [
						"{{base_url}}{{endpoint}}"
					]
				}
			},
			"response": []
		}
	]
}